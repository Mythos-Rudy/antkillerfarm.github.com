---
layout: post
title:  C/C++编程心得（二）, boost
category: language 
---

# C/C++编程心得

## 动态链接

这两天实践了一下怎样在linux下创建动态链接。感觉网上的资料虽然翔实，但仍然有疏漏之处。

1）g++和gcc的区别

本来只想给链接的，以显示这不是我的原创。但是现在的链接失效的也太快了。。。囧

只好拿华丽的分隔符来表示引用的内容。

----

误区一:gcc只能编译c代码,g++只能编译c++代码

两者都可以，但是请注意：

1.后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。

2.编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。
 
误区二:gcc不会定义__cplusplus宏，而g++会

实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。
 
误区三:编译只能用gcc，链接只能用g++

原因基本同第一条。此外，g++基本等同gcc -lstdc++。

----

因此，某些时候编不过去，可以试试换换cc的值。

2）gcc4.1.1下似乎对类型检查严了一些，dlsym返回的void*类型不能转换为相应的函数指针类型，需要强制转换。某些网上的例子在这里编不过去。

3）显式调用时,要注意动态库函数的声明,可能要加`extern "C"`才能正常执行。（显式调用是运行时加载，所以编译能过，执行却不对了。）可以用nm命令看看链接库的符号表，以确定问题所在。

## strtok

strtok函数多用于分割字符串，但它会改变被分割字符串的值。因此，如果该字符串以后还有用的话，需要首先复制该字符串，然后对复制的字符串执行strtok函数。

## malloc与calloc

两者都是动态分配内存。

**主要的不同**：malloc不初始化分配的内存，已分配的内存中可以是任意的值。calloc初始化已分配的内存为0。

**次要的不同**：calloc返回的是一个数组，而malloc返回的是一个对象。

## 惰性求值

http://www.cnblogs.com/gtarcoder/p/4811614.html

c++11实现l延迟调用（惰性求值）

http://www.fuzihao.org/blog/2016/02/10/C-%E5%AE%9E%E7%8E%B0%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC/

C++实现惰性求值

## gcc链接器

### gcc和ld的差异

理论上gcc做链接和ld做链接，应该是一样的效果，然而实际情况要复杂一些。有的厂商的工具链会给gcc添加一些环境变量之类的私货，所以两者的行为就变的很有差异了。遇到这种问题，互换是一种好的解决问题的思路。

### 链接顺序

有的链接器对链接顺序有要求，一般按照c代码、自定义库、标准库的顺序来链接，也就是越基础底层的库，越在后面。（这个顺序正好和声明的顺序相反）

`gcc -c ./sparse_matrix.c -o sparse_matrix.o -luserlib -lm`

但是如果有一系列很底层的库，他们太底层了，以至于会出现相互依赖的情况(circular dependence)，那gcc提供了一个option很好的解决了这个情况：

`-Wl,--start-group -lmy_lib -lyour_lib -lhis_lib -Wl,--end-group`

再比如下面的例子：

https://github.com/antkillerfarm/antkillerfarm_crazy/tree/master/helloworld/linux_so

`gcc -o main_link main_link.c -L. -lhello`

这条命令中的main_link.c如果放到`-lhello`之后就会出问题。也考虑使用`--start-group`和`--end-group`之类的链接选项解决链接顺序问题。

参考：

https://stackoverflow.com/questions/27475977/c-undefined-reference-to-sqrt-even-with-lm

C - undefined reference to “sqrt” even with '-lm'

## 左值和右值

**左值**是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；

**右值**当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。

一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。

左值语法：`type &引用名 = 左值表达式;`

右值语法：`type &&引用名 = 右值表达式;`

参考：

https://www.cnblogs.com/ldlchina/p/6608154.html

C++11右值引用和std::move语句实例解析

## 各类ptr

**auto_ptr**：它允许程序员创建一个指向某种资源的指针对象，当该对象离开它的作用域时，它所指向的资源也会被自动释放。

在原本的C++中，new和delete必须配对使用，然而给每个异常处理分支添加delete是一件很麻烦的事。auto_ptr就是用来干这事的，它无需显式调用delete。

对auto_ptr的赋值和拷贝会导致原来的auto_ptr变为NULL，从而无效化。

**unique_ptr**：auto_ptr是全局唯一的，且不采用引用计数管理，因此，赋值和拷贝都是不必要的，且会造成混淆。（尤其拷贝会导致原来的auto_ptr变为NULL，这个还能叫做拷贝吗？）因此，auto_ptr在后续标准中，不再推荐使用，而是用unique_ptr替代。unique_ptr默认不支持赋值和拷贝，确需使用，要与std::move配合方可。否则会编译出错。

unique_ptr早先在boost库中的时候，也叫做scoped_ptr。

**shared_ptr**：为多个拥有者管理内存中对象的生命周期而设计的。在你初始化一个 shared_ptr 后，你可以复制它，把函数参数的值递给它，并把它分配给其它 shared_ptr 实例。所有实例指向同一个对象，并共享访问一个“控制块”，即每当一个新的shared_ptr 被添加时，递增和递减引用计数，超出范围，则复位。当引用计数到达零时，控制块删除内存资源和自身。

**weak_ptr**：如果对象A中有对象B的shared_ptr，而对象B中又有对象A的shared_ptr，那么就会出现循环引用的情况。这时可以使用weak_ptr。两者的区别在于新建shared_ptr会增加引用计数，而weak_ptr不会。

## 参考

https://mp.weixin.qq.com/s/Hpn7KqYlBKz0JdryiozqyQ

每个开发者都应该了解的一些C++特性

https://www.cnblogs.com/wuchanming/p/3913492.html

emplace_back与push_back的区别

# boost

## 安装&编译

boost直接安装：

`sudo apt install libboost-all-dev`

编译：

{% highlight bash %}
./bootstrap.sh
./b2 install link=static cxxflags=-fPIC --with-test --prefix=</path/to/install>
{% endhighlight %}

boost的组件有很多，这里只编译了test组件。

>注意：指定生成目录的时候，stage使用stagedir选项，而install使用prefix选项。

## boost.test

boost.test是一个C++的单元测试框架。

代码示例：

https://github.com/antkillerfarm/antkillerfarm_crazy/tree/master/cpp/boost_test

要点：

- 测试代码无须main函数。

- 编译：`-DBOOST_TEST_DYN_LINK`

- 链接：`-lboost_unit_test_framework`

打印所有的log：

`unit_test --log_level=all`

参考：

https://www.ibm.com/developerworks/cn/aix/library/au-ctools1_boost/

了解Boost单元测试框架

https://www.ibm.com/developerworks/cn/aix/library/au-ctools2_cppunit/index.html

了解CppUnit

https://www.ibm.com/developerworks/cn/aix/library/au-ctools3_ccptest/

了解CppTest。上面这3篇算是比较权威的C++单元测试工具的教程了，作者都是Arpan Sen。

https://my.oschina.net/vaero/blog/227528

C++单元测试：boost.test

https://remonstrate.wordpress.com/2011/07/06/boost-%e7%9a%84-unit-test/

boost的unit test

## googletest

安装：

`sudo apt install libgtest-dev`

代码：

https://github.com/google/googletest

参考：

https://www.ibm.com/developerworks/cn/aix/library/au-googletestingframework.html

Google C++ Testing Framework简介
