---
layout: post
title:  C/C++编程心得（二）, Python（三）
category: language 
---

# C/C++编程心得

## 动态链接

这两天实践了一下怎样在linux下创建动态链接。感觉网上的资料虽然翔实，但仍然有疏漏之处。

1）g++和gcc的区别

本来只想给链接的，以显示这不是我的原创。但是现在的链接失效的也太快了。。。囧

只好拿华丽的分隔符来表示引用的内容。

****
误区一:gcc只能编译c代码,g++只能编译c++代码

两者都可以，但是请注意：

1.后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。

2.编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。
 
误区二:gcc不会定义__cplusplus宏，而g++会

实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。
 
误区三:编译只能用gcc，链接只能用g++

原因基本同第一条。此外，g++基本等同gcc -lstdc++。

****

因此，某些时候编不过去，可以试试换换cc的值。

2）gcc4.1.1下似乎对类型检查严了一些，dlsym返回的void*类型不能转换为相应的函数指针类型，需要强制转换。某些网上的例子在这里编不过去。

3）显式调用时,要注意动态库函数的声明,可能要加`extern "C"`才能正常执行。（显式调用是运行时加载，所以编译能过，执行却不对了。）可以用nm命令看看链接库的符号表，以确定问题所在。

## strtok

strtok函数多用于分割字符串，但它会改变被分割字符串的值。因此，如果该字符串以后还有用的话，需要首先复制该字符串，然后对复制的字符串执行strtok函数。

## malloc与calloc

两者都是动态分配内存。

**主要的不同**：malloc不初始化分配的内存，已分配的内存中可以是任意的值。calloc初始化已分配的内存为0。

**次要的不同**：calloc返回的是一个数组，而malloc返回的是一个对象。

## 惰性求值

http://www.cnblogs.com/gtarcoder/p/4811614.html

c++11实现l延迟调用（惰性求值）

http://www.fuzihao.org/blog/2016/02/10/C-%E5%AE%9E%E7%8E%B0%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC/

C++实现惰性求值

## gcc链接器

### gcc和ld的差异

理论上gcc做链接和ld做链接，应该是一样的效果，然而实际情况要复杂一些。有的厂商的工具链会给gcc添加一些环境变量之类的私货，所以两者的行为就变的很有差异了。遇到这种问题，互换是一种好的解决问题的思路。

### 链接顺序

有的链接器对链接顺序有要求，一般按照c代码、自定义库、标准库的顺序来链接，也就是越基础底层的库，越在后面。（这个顺序正好和声明的顺序相反）

`gcc -c ./sparse_matrix.c -o sparse_matrix.o -luserlib -lm`

但是如果有一系列很底层的库，他们太底层了，以至于会出现相互依赖的情况(circular dependence)，那gcc提供了一个option很好的解决了这个情况：

`-Wl,--start-group -lmy_lib -lyour_lib -lhis_lib -Wl,--end-group`

再比如下面的例子：

https://github.com/antkillerfarm/antkillerfarm_crazy/tree/master/helloworld/linux_so

`gcc -o main_link main_link.c -L. -lhello`

这条命令中的main_link.c如果放到`-lhello`之后就会出问题。也考虑使用`--start-group`和`--end-group`之类的链接选项解决链接顺序问题。

参考：

https://stackoverflow.com/questions/27475977/c-undefined-reference-to-sqrt-even-with-lm

C - undefined reference to “sqrt” even with '-lm'

## 参考

https://mp.weixin.qq.com/s/Hpn7KqYlBKz0JdryiozqyQ

每个开发者都应该了解的一些C++特性

# Python

## eval

eval函数用来执行一个字符串表达式，并返回表达式的值。

示例：

`eval('pow(2,2)')`

粗看起来，eval函数在上面的例子中有些多此一举。然而如果字符串来自外部的话，就完全不同了。我们完全可以在任何地方嵌入python脚本。然后，只需要在用到的时候，找到并加载该字符串即可。

## argparse

https://blog.csdn.net/It_way/article/details/44815141

python 命令行参数解析 argparse简单分析

## pickle

pickle提供了一个简单的持久化功能。可以将对象以文件（后缀名一般为*.pkl）的形式存放在磁盘上。

参考：

https://blog.csdn.net/sinat_29552923/article/details/70833455

Python pickle模块学习

## dill

dill是pickle的威力加强版。

除了提供pickle的功能之外，还可浏览对象的源代码。

示例：

`dill.source.getsource(func)`

## Sqlite

Ubuntu下的安装方法是：

`sudo apt-get install sqlite`

Python自带了pysqlite包，用于调用sqlite。

pysqlite的helloworld程序可参见：

https://github.com/antkillerfarm/antkillerfarm_crazy/blob/master/python/pysqlite-helloworld.py

可以使用sqlite_bro软件包，查看sqlite数据库。安装方法：

`sudo pip install sqlite_bro`

参考：

https://mp.weixin.qq.com/s/HcmOmwWQFBIOZs8p3nr7CQ

让Python更加充分的使用Sqlite3

## python调用GTK函数的一般规则

众所周知，GTK库是用C语言编写的，其相关的文档提供的也是C函数的接口，python接口的文档相对较少，获得也不太容易。因此有必要掌握一下这方面基本的命名规则。（这里只讲方法，对深层次的调用原理不做探究。）

1）类初始化函数

C:`GtkWidget * gtk_button_new (void);`

python:`button = Gtk.Button()`

这里除了把C函数式的写法，替换成python的类的写法之外，并无其他差异。

2）普通类成员函数

C:`void gtk_container_add (GtkContainer *container, GtkWidget *widget);`

python:`button.add(image)`

可以看出，C函数的第一个表示self类指针的参数被省略掉了。

3）回调函数

这里以按钮的click事件回调为例：

C:`void user_function (GtkButton *button, gpointer user_data)`

python:

`button.connect("clicked", self.playToggled)`

`def playToggled(self, w):`

这里的情况要复杂的多。首先在事件回调注册的时候，由于我们并没有给user_data赋值，因此照理说playToggled函数，只有button这一个参数。但实际传递给playToggled函数的有两个参数，self是一个用于占位的参数，w对应button，没有东西对应user_data。

4）用于输出的参数

C:`void gst_message_parse_error (GstMessage *message, GError **gerror, gchar **debug);`

python:`err, debug = message.parse_error()`

这个例子中的gerror和debug都是用于输出的参数。如果只想得到其一，还可用以下方法:

`debug = message.parse_error()[2]`

5）枚举类型

C:

{% highlight c %}
enum GstSeekFlags
{
  GST_SEEK_FLAG_FLUSH,
  ...
}
{% endhighlight %}

python:`Gst.SeekFlags.FLUSH`

6）宏常量

C:`#define GST_CLOCK_TIME_NONE ((GstClockTime) -1)`

python:`Gst.CLOCK_TIME_NONE`

7）类型转换

大多数情况下，类型转换自动完成，并无什么问题。这里只讨论特殊的情况。

C:

{% highlight c %}
gst_element_seek (pipeline, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
                         GST_SEEK_TYPE_SET, time_nanoseconds,
                         GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
{% endhighlight %}

python:

{% highlight python %}
self.player.seek(1.0, Gst.Format.TIME, Gst.SeekFlags.FLUSH, Gst.SeekType.SET,\
                 time_nanoseconds, Gst.SeekType.NONE, Gst.CLOCK_TIME_NONE)
{% endhighlight %}

这里首先按照一般的方法，将C代码转化成python代码。但是运行之后，产生如下错误：

`OverflowError: long too big to convert`

究其原因，gst_element_seek的最后一个参数是uint64类型的。但python原生并不支持该类型，而是将之转换成int类型（实际上是int64类型），这样的话，GST_CLOCK_TIME_NONE的值显然超出了int64所能表示的范围。

解决的办法是使用ctypes库，将

`Gst.CLOCK_TIME_NONE`

改为

`c_long(Gst.CLOCK_TIME_NONE).value`

## zip

Python的zip函数和数据压缩的zip算法没有任何关系。

它的典型用法如下：

{% highlight python %}
>>> name=['song','ping','python']
>>> age=[26,26,27]
>>> zip(name,age)
[('song', 26), ('ping', 26), ('python', 27)]
>>> for n,a in zip(name,age):
...   print n,a
{% endhighlight %}

zip函数属于Python的Built-in Functions，类似的函数还有：

https://docs.python.org/3.6/library/functions.html

参考：

http://www.cnblogs.com/frydsh/archive/2012/07/10/2585370.html

Python的zip函数

## signal

signal包用于处理系统消息。

代码示例：

{% highlight python %}
import signal

def handler(signum, frame):
    print 'Signal handler called with signal', signum
    raise IOError("Couldn't open device!")

# Set the signal handler and a 5-second alarm
signal.signal(signal.SIGALRM, handler)
{% endhighlight %}

## Captcha

Captcha是一个Python验证码库，能够生成音频和图片验证码。

>CAPTCHA是Completely Automated Public Turing Test to Tell Computers and Humans Apart (全自动区分计算机和人类的图灵测试)的简称. CAPTCHA的目的是区分计算机和人类的一种程序算法，是一种区分用户是计算机和人的计算程序，这种程序必须能生成并评价人类能很容易通过但计算机却通不过的测试。

代码：

https://github.com/lepture/captcha

这个库可用于生成大量有标签的验证码，是DL入门的必备工具。

参考：

https://mp.weixin.qq.com/s/m4rNUFV4VGUBI7aWv5fgbw

中文项目：快速识别验证码，CNN也能为爬虫保驾护航

https://zhuanlan.zhihu.com/p/26078299

使用深度学习来破解captcha验证码

https://mp.weixin.qq.com/s/NsaMcgufLYO3i6eG1WO_VA

我不是机器人：谷歌最新版验证码系统ReCaptcha破解已开源

其他类似项目还包括：

| 语言 | 名称 | 网址 |
|:--:|:--:|:--:|
| Java | JCaptcha | http://jcaptcha.sourceforge.net/ |
| Java | SimpleCaptcha | http://simplecaptcha.sourceforge.net/ |
| Java | kcaptcha | http://captcha.ru/en/kcaptcha/ |
| Java | patchca | https://github.com/pusuo/patchca |
| Java | SkewPassImage | http://skewpassim.sourceforge.net/ |
| Java | Internet Captcha | http://www.icaptcha.com/ |
| Java | Cage | http://akiraly.github.io/cage/ |
