---
layout: post
title:  VAE（一）——Variational Inference, Vanilla VAE（1）
category: GAN & VAE 
---

# Variational Inference

论文：

《Variational Inference: A Review for Statisticians》

《A Tutorial on Variational Bayesian Inference》

《Stochastic Variational Inference》

《An Introduction to Variational Methods for Graphical Models》

泛函/变分方面的基本知识可参见《数学狂想曲（十二）》。

ELOB(Evidence Lower Bound)

参考：

https://zhuanlan.zhihu.com/p/49401976

变分推断

https://www.zhihu.com/question/41765860

如何简单易懂地理解变分推断(variational inference)？

http://nooverfit.com/wp/当变分推断（variational-inference）遇上神经网络，贝叶斯深度/

当变分推断（variational inference）遇上神经网络，贝叶斯深度学习以及Pytorch开源代码

https://blog.csdn.net/aws3217150/article/details/57072827

变分贝叶斯推断(Variational Bayes Inference)简介

https://www.cnblogs.com/yifdu25/p/8181185.html

变分推断（Variational Inference）

http://blog.huajh7.com/2013/03/06/variational-bayes/

变分贝叶斯算法理解与推导

# Vanilla VAE

变分自编码器（Variational Auto-Encoder，VAE）是Autoencoder的一种扩展。

论文：

《Auto-Encoding Variational Bayes》

>Diederik P. Kingma，荷兰人，Univ. of Amsterdam博士（2017）。现为OpenAI科学家。VAE和Adam optimizer的发明者。   
>个人主页：   
>http://dpkingma.com

除了原始论文之外，以下综述也很有名：

《Tutorial on Variational Autoencoders》

代码：

https://github.com/keras-team/keras/blob/master/examples/variational_autoencoder.py

Keras官方提供的代码示例

以下部分主要摘自：

https://kexue.fm/archives/5253

变分自编码器（一）：原来是这么一回事

## 分布变换

通常我们会拿VAE跟GAN比较，的确，它们两个的目标基本是一致的——希望构建一个从隐变量Z生成目标数据X的模型，但是实现上有所不同。更准确地讲，它们是假设了Z服从某些常见的分布（比如正态分布或均匀分布），然后希望训练一个模型$$X=g(Z)$$，这个模型能够将原来的概率分布映射到训练集的概率分布，也就是说，它们的目的都是进行分布之间的映射。

现在假设Z服从标准的正态分布，那么我就可以从中采样得到若干个$$Z_1, Z_2, \dots, Z_n$$，然后对它做变换得到$$\hat{X}_1 = g(Z_1),\hat{X}_2 = g(Z_2),\dots,\hat{X}_n = g(Z_n)$$，我们怎么判断这个通过f构造出来的数据集，它的分布跟我们目标数据集的分布是不是一样的呢？

![](/images/img2/VAE.png)

**生成模型的难题就是判断生成分布与真实分布的相似度，因为我们只知道两者的采样结果，不知道它们的分布表达式。**

有读者说不是有KL散度吗？当然不行，因为KL散度是根据两个概率分布的表达式来算它们的相似度的，然而目前我们并不知道它们的概率分布的表达式，我们只有一批从构造的分布采样而来的数据$$\{\hat{X}_1,\hat{X}_2,\dots,\hat{X}_n\}$$，还有一批从真实的分布采样而来的数据$$\{X_1,X_2,\dots,X_n\}$$（也就是我们希望生成的训练集）。我们只有样本本身，没有分布表达式，当然也就没有方法算KL散度。

虽然遇到困难，但还是要想办法解决的。GAN的思路很直接粗犷：既然没有合适的度量，那我干脆把这个度量也用神经网络训练出来吧。而VAE则使用了一个精致迂回的技巧。

## VAE的传统理解

首先我们有一批数据样本$$\{X_1,\dots,X_n\}$$，其整体用X来描述，我们本想根据$$\{X_1,\dots,X_n\}$$得到X的分布p(X)，如果能得到的话，那我直接根据p(X)来采样，就可以得到所有可能的X了（包括$$\{X_1,\dots,X_n\}$$以外的），这是一个终极理想的生成模型了。当然，这个理想很难实现，于是我们将分布改一改：

$$p(X)=\sum_Z p(X|Z)p(Z)$$

此时$$p(X\mid Z)$$就描述了一个由Z来生成X的模型，而我们假设Z服从标准正态分布，也就是$$p(Z)=\mathcal{N}(0,I)$$。如果这个理想能实现，那么我们就可以先从标准正态分布中采样一个Z，然后根据Z来算一个X，也是一个很棒的生成模型。接下来就是结合自编码器来实现重构，保证有效信息没有丢失，再加上一系列的推导，最后把模型实现。框架的示意图如下：

![](/images/img2/VAE_2.png)

看出了什么问题了吗？如果像这个图的话，我们其实完全不清楚：究竟经过重新采样出来的$$Z_k$$，是不是还对应着原来的$$X_k$$，所以我们如果直接最小化$$\mathcal{D}(\hat{X}_k,X_k)^2$$（这里D代表某种距离函数）是很不科学的，而事实上你看代码也会发现根本不是这样实现的。
