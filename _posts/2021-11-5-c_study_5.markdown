---
layout: post
title:  C/C++编程心得（五）, C++ Test framework, Matlab
category: language 
---

* toc
{:toc}

# C/C++参考资源

## spaceship operator

spaceship operator: `<=>`

C++20引入了spaceship operator：

- 如果`a<b`，返回std::strong_ordering::less。
- 如果`a>b`，返回std::strong_ordering::greater。
- 如果a与b全等/相等，返回std::strong_ordering::equal。

这和`strcmp`的设计理念类似。

此外，还有关系运算符的重载推导，定义了`<=>`之后，其他诸如`==`、`!=`、`<`、`<=`、`>`、`>=`的关系运算自动成立，无需再写相应的重载函数了。同理，如果定义了`==`，那么`!=`就自动成立了。

参考：

https://cloud.tencent.com/developer/article/1352324

C++20草案中的宇宙飞船运算符(<=>,spaceship operator)

## 线程安全注解

线程安全注解是现代C++开发的机制，可以在代码编译阶段检查锁的使用情况，从而发现线程同步的相关问题。该功能目前只有clang编译器支持。

https://blog.csdn.net/qq_32648921/article/details/109114887

线程安全注解

## Implementation-defined、Unspecified、Undefined

Implementation-defined：C标准没有明确规定，但是要求编译器必须对此做出明确规定，并写在编译器的文档中。

Unspecified：C标准没有明确规定，编译器可以自己决定，不必写在编译器的文档中。

Undefined：C标准没规定怎么处理，编译器很可能也没规定。

https://www.cnblogs.com/MagicLetters/archive/2011/08/03/2126471.html

C语言中关于Implementation-defined、Unspecified和Undefined

## 在构造函数内部调用构造函数

```cpp
struct CLS
{
    int m_i;
    CLS( int i ) : m_i(i){}
    CLS()
    {
        CLS(0);
    }
};
```

如上，在`CLS()`调用`CLS(0);`会创建一个新的临时对象，达不到重载的目的。

应该怎么做呢？`new (this)CLS(0);`

https://www.cnblogs.com/stemon/p/4834043.html

在构造函数内部调用构造函数

## 临时对象的生命周期

```cpp
string test()
{
    return "abc";
}

int main()
{
    const char *p = test().c_str();
    cout << p << endl;

    return 0;
}
```

`string("abc")`是一个临时对象，在执行完`const char *p = string("abc").c_str();`这个语句后，临时对象就析构了，而不会等到块结束。

https://blog.csdn.net/stpeace/article/details/46461167

聊聊C++临时对象的析构时间点

## switch...case

```c
switch (reg) {
       case TAS5086_CLOCK_CONTROL ... TAS5086_BKNDERR:
       return 1;
       case TAS5086_INPUT_MUX:
       case TAS5086_PWM_OUTPUT_MUX:
       return 4;
}
```

可以用上面的办法，少写一些case语句。

## uint8_t

对于要求严格位宽的场合，应用程序可以使用uint8_t，uint16_t，uint32_t来获得移植时的一致性。它的头文件是inttypes.h。

## 并发与多线程

https://blog.csdn.net/qq_38231713/category_10001159.html

一个C++11并发与多线程的专栏

## K&R风格

在C语言的函数定义上，我们通常用的函数定义方式为ANSI C的函数定义方式。但是在C语言之父创立C语言之时，函数的定义形式并非现在我们所见到的形式。

这种风格被称为K&R风格，多见于一些历史悠久的项目或者老的书籍中。出于兼容性考虑，现代的C编译器仍然支持K&R风格。

>记得大学学C语言，用的是谭浩强的书。当时，授课老师看不上谭的书，于是另外推荐了一本，那本书更古老，用的就是所谓的K&R风格。。。但在实际工作中，从来没见过K&R风格的代码。。。

详见：

http://blog.chinaunix.net/uid-7426920-id-2627743.html

ANSI和K&R两种函数定义风格

## 参考

https://zhuanlan.zhihu.com/p/23016264

这么多款STL，总有一款适合你

https://mp.weixin.qq.com/s/Hpn7KqYlBKz0JdryiozqyQ

每个开发者都应该了解的一些C++特性

https://www.cnblogs.com/wuchanming/p/3913492.html

emplace_back与push_back的区别

https://zhuanlan.zhihu.com/p/82895086

当我们谈论C++时，我们在谈论什么？

https://mp.weixin.qq.com/s/pxyTlQn4wx-N_MaWZc0oAQ

漫谈C++的各种检查

https://mp.weixin.qq.com/s/LchYGGcSbIMVGxO0Uea0RA

深入C++回调

https://blog.csdn.net/hahahacff/article/details/39504699

Java中创建对象的时候代码执行顺序(这个问题C++应该也存在)

https://blog.csdn.net/msq19895070/article/details/7910969

嵌入式程序员应知道的几个基本问题

http://dev.yesky.com/393/3007393.shtml

深入理解C++中的mutable关键字

http://blog.csdn.net/apunix/archive/2008/01/14/2043945.aspx

UNREFERENCED_PARAMETER的作用

https://mp.weixin.qq.com/s/1ELGzBkIdO1xa6LZV80raQ

C++中Future和Promise的一种简单实现

https://www.zhihu.com/question/24301047

如何理解C++11的六种memory order？

https://mp.weixin.qq.com/s/en9T7WfQDvFan9tu1q8oRA

c++11与内存模型

https://mp.weixin.qq.com/s/2Lq93xPffOVZB8WvbkhCDg

函数调用的三种约定，你都清楚吗

https://mp.weixin.qq.com/s/m-dLZGAvY5BdVRfVWSpS2g

C++11的异步操作不只是thread

https://zhuanlan.zhihu.com/p/58976871

编程风格之声明式与命令式的区别

https://www.zhihu.com/question/447592340

C语言的源程序是可以直接运行吗？（C语言的解释执行）

https://zhuanlan.zhihu.com/p/346465585

极大提高你开发效率的C++ tricks

https://www.zhihu.com/question/280665935

为什么C/C++要分为头文件和源文件？

https://www.zhihu.com/question/485183321

一个接口只有一个实现类，写接口的意义是什么？只写类不写接口不是更简单且清晰吗？

https://www.zhihu.com/question/36642771

C++的string为什么不提供split函数？

# C++ Test framework

## boost.test

boost.test是一个C++的单元测试框架。

代码示例：

https://github.com/antkillerfarm/antkillerfarm_crazy/tree/master/cpp/boost_test

要点：

- 测试代码无须main函数。

- 编译：`-DBOOST_TEST_DYN_LINK`

- 链接：`-lboost_unit_test_framework`

打印所有的log：

`unit_test --log_level=all`

参考：

https://www.ibm.com/developerworks/cn/aix/library/au-ctools1_boost/

了解Boost单元测试框架

https://www.ibm.com/developerworks/cn/aix/library/au-ctools2_cppunit/index.html

了解CppUnit

https://www.ibm.com/developerworks/cn/aix/library/au-ctools3_ccptest/

了解CppTest。上面这3篇算是比较权威的C++单元测试工具的教程了，作者都是Arpan Sen。

https://my.oschina.net/vaero/blog/227528

C++单元测试：boost.test

https://remonstrate.wordpress.com/2011/07/06/boost-%e7%9a%84-unit-test/

boost的unit test

## googletest

安装：

`sudo apt install libgtest-dev`

代码：

https://github.com/google/googletest

`gtest_filter`是一个很有用的选项。

示例：

`./foo_test --gtest_filter=FooTest*.*-FooTest.Bar:FooTest2.Bar`

运行所有“测试案例名称(testcase_name)”为FooTest的案例，但是除了FooTest.Bar和FooTest2.Bar。

`-`表示去除，`:`表示并列。

参考：

https://www.ibm.com/developerworks/cn/aix/library/au-googletestingframework.html

Google C++ Testing Framework简介

https://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html

玩转Google开源C++单元测试框架Google Test系列(gtest)

## CTest

CTest是CMake集成的一个测试工具。

参考：

https://www.cnblogs.com/457220157-FTD/p/4139149.html

CTest

## doctest

官网：

https://github.com/onqtam/doctest

# Matlab

![](/images/img4/Matlab.jpg)

在MATLAB软件诞生之前，大约1965年，计算机只能生成和输出二维图像，对于L-型膜结构(L-Shaped Membrane)只能生成下图左侧的二维平面效果。直到1990年，MATLAB 3.5发布，3.5版本利用了隐藏线算法(Hidden Line Algorithm)，可以实现黑白网格的三维立体图像的生成。1993年，MATLAB 4进一步实现了彩色化。1995年，MATLAB 4.2利用了网格光滑化算法(Crude Shaping Algorithm)将L型网格进一步光滑处理。1995年，MATLAB 5实现了生成完全光滑和打光效果。

而Mathworks公司也将他们引以为傲的进步作为了MATLAB软件的图标！这个图标反映的正是Mathworks技术的不断迭代升级。

至于为啥是L-Shaped Membrane而不是其他呢？因为这是Mathworks创始人之一Moler的博士课题

https://www.zhihu.com/answer/1294927798

如果中国重新开发像MATLAB、solidworks这样的软件大概需要多久？

## 参考

https://zhuanlan.zhihu.com/p/30905298

XML和MATLAB交互的基本操作

https://mp.weixin.qq.com/s/QkICCbTp53lWOyeZx63-sw

后MATLAB时代的七种开源替代，一种堪称完美！

https://mp.weixin.qq.com/s/vV8kFF7e1uxjMR48_uRcSw

MATLAB动画没有密秘

## GNU Octave

GNU Octave是Matlab的一个开源实现。它拥有和后者兼容的语法，类似的IDE，并实现了大部分的基础库。

官网：

https://gnu.org/software/octave/

安装方法:

`sudo apt install octave`

## spyder

spyder是一个Python的IDE，提供了和Matlab类似的数据可视化界面。

安装：

`sudo apt install spyder`

## GeoGebra

GeoGebra是一个结合“几何”、“代数”与“微积分”的动态数学软件，由佛罗里达州亚特兰大学的数学教授Markus Hohenwarter所设计。

官网：

https://www.geogebra.org/

GeoGebra官网包含了很多网友分享的几何绘图，所以常用图形就不要自己画了，找个现成的改改更合适。

## Maxima

微积分的数值解很多软件都能计算，但解析解就不行了。Maxima就是这样一款Computer Algebra System的软件。

官网：

http://maxima.sourceforge.net/

# Lazarus

Lazarus为开放的IDE，且在Linux下表现良好，目前被中国计算机学会指定为NOI系列竞赛的Pascal语言推荐IDE。

官网：

https://www.lazarus-ide.org/
